---
title: "ECo 602 - Analysis of Environmental Data"
subtitle: "Final Project Template: Data Analysis"
author: "Heather Parry"
date: "Fall 2020"
output:
  html_document:
    theme: readable
    toc: TRUE
    toc_float: TRUE
editor_options:
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
options(knitr.duplicate.label = TRUE)
options(knitr.duplicate.label = TRUE)
```



<!-- The following text won't be displayed in your document.  It tells R how to make nicer looking buttons for your tabbed content. -->

<style type="text/css" rel="stylesheet">

.btn {
    border-width: 0 0 0 0;
    font-weight: normal;
    text-transform: none;
}

.btn-default {
    color: #2ecc71;
    background-color: #ffffff;
    border-color: #ffffff;
}
</style>




# Introduction

Type a brief introduction here.


# Functions 1: Data Structure Functions {.tabset .tabset-pills}

Look at the source code for the final project template, you'll notice the text:

{.tabset .tabset-pills}

This creates tabbed content for all the following sections that are one-level below.

- If you include them on a primary header (one #), all of the subsequent secondary headers will in tabs.




## `c()`

The following is the markdown text needed to reproduce my code example for `c()`:


The function `c()` *combines* or *concatenates* its arguments into a vector (a 1-dimensional data structure consisting of 1 or more elements).

- All of the elements must be of the same *type*.
  - I can't combine character and numeric types in the same call to `c()`

Here's two examples using numeric and character data types:

```{r}
# Create a vector of numbers:
num_vec  = c(1, 4, 8, 9, 13)

# Create a vector of characters:
char_vec = c("a", "fish", "data is cool")
```

I can show the contents of a vector by typing the name of the vector, or using the `print()` function.

```{r}
# Typing the name of the vector into the console prints the contents
num_vec

# The print() function accomplishes the same task:
print(char_vec)
```


## `data.frame()`

A data frame can hold numeric, character or logical data types. Within a column all elements have the same data type, but different columns can be of different data type.
```{r}
data.frame(letters = c("b", "w", "B"),
           numbers_1 = c(34, 6, 123454))
```


## `matrix()`

A matrix is an array that can hold numeric, character or logical data types but it can only hold one data type at a time.

If we want to make a matrix with 3 rows that contain the numbers 1 up to 9 we would use the following code `matrix(1:12, byrow = true, nrow = 3)`

The first argument (1:12) is the collection of elements that R will arrange into the rows and columns of the matrix. 

The second argument `byrow` tells R that the matrix is filled by the rows. If you want the matrix to be filled by the columns, we just place byrow = FALSE.

The third argument `nrow` tells R that the matrix how many rows there should be in the matrix.

```{r}
matrix(1:12, byrow = TRUE, nrow = 3)
```



## `length()`
The `length()` function gives you the number of elements in a vector or list. In the vector example above we made a vector with 5 elements called `num_vec`. We can find the number of elements in `num_vec` by using `length()`.

```{r}
# num_vec is a vector we created in the vector example
num_vec  = c(1, 4, 8, 9, 13)

length(num_vec)
```



## `nrow()`
The function `nrow()` will tell you how many rows are in your data set. This can be very useful if you are trying to find out how many observations are in your dataset, if each row is one observation.

```{r}
# I created an example data frame called example_dat
example_dat =data.frame(letters = c("b", "w", "B"),
           numbers_1 = c(34, 6, 123454))

# I printed the data frame to look at the constructed data frame
print(example_dat)

# to find the number of rows in example_dat, I used the nrow() function
nrow(example_dat)

```



## `ncol()`
The `ncol()` function will tell you the number of columns in your data frame. I will use the data frame from `nrow()` called example_dat to illustrate how to use `ncol()`
```{r}
# I printed the example_dat data frame to compare the data frame to the results from ncol(example_dat
print(example_dat)

ncol(example_dat)
```
There are two columns in the data frame, "letters" and "numbers_1" and the ncol() function also told us that there are 2 columns in the data frame.

## `dim()`
The `dim()` function tells you the dimensions of the data frame, or matrix. Again I used the data frame from the previous examples called "example_dat"

```{r}
dim(example_dat)
```
The results from dim(example_dat) tells us that that data frame consists of 3 rows and 2 columns.


# Functions 2: Numerical Data Exploration  {.tabset .tabset-pills}

## `summary()`
The `summary()` function allows you to view all of the numerical summaries of the statistics for the data frame that you are interested in examining.

It gives you the quantiles, mean, median, mode, minimum and maximum values.

```{r}
library(here)
#I downloaded the catrate data into R and convert it to a data frame with the read.csv(here(...)) function
catrate = read.csv(here("data", "catrate.csv"))

# to get the summary of the catrate data I used the summary() function
summary(catrate)

```


## `mean()`
To find the mean value of a category or column in your data frame you can use the `mean()` function.
```{r}
# I want to find the mean value of the catastrophic rate in my data frame catrate. 
mean(catrate$cat.rate)
```



## `sd()`
To find the standard deviation value of a category or column in your data frame you can use the `sd()` function.
```{r}
# I want to find the standard deviation value of the catastrophic rate in my data frame named catrate.
sd(catrate$cat.rate)
```


 


# Functions 3: Graphical Data Exploration {.tabset .tabset-pills}


## `plot()`
I can use a `plot()` to create a scatterplot
```{r scatterplot_1, fig.asp=1.0, fig.height=15}

#load the penguin package
require(palmerpenguins)


plot(bill_length_mm~ body_mass_g, 
     data= penguins,
     col = 2,
     pch = 16, 
     cex = .5,
     main= "Penguin body mass vs. bill length",
     xlab = "body mass, g",
     ylab = "bill lengh, mm",
     xlim = c(2500, 6500),
     ylim = c(30, 60))
# pch is the symbols used in the scatterplot
# col is the color of the points
# cex is the size of the points
# xlim and ylim are the limits of the x and y axis and are in a vector form
```


## `boxplot()`

I can use `boxplot()` to make a simple or conditional boxplot.

Below is a simple boxplot looking at the body mass of all of the penguins in the Palmer Penguins dataset.
```{r}
require(palmerpenguins)
penguins<- penguins

boxplot(penguins$body_mass_g)

```

The conditional boxplot below looks at the body mass of the penguins in the Palmer Penguin dataset by their species.
```{r}
boxplot(body_mass_g ~ species, data = penguins)

```


## `hist()`


Below is a histogram of the body mass of all of the penguins in the Palmer Penguins dataset using `hist()`
```{r}
hist(penguins$body_mass_g, breaks = 80, main = "Histogram of Body Mass", xlab = "body mass (g)")

#breaks = is the number of columns that the histogram is broken up into.
#main = is the title of the histogram
#xlab = is the label of the x axis

```


## `par ()`
The `par()` function allows you to arrange multiple plots in one window.

```{r}
par(mfrow = c(1,2))
boxplot(penguins$body_mass_g)
boxplot(body_mass_g ~ species, data = penguins)

dev.off()

#dev.off() clears the plot window
#mfrow() tells R how to arrange the boxplots. c(1,2) tells R to arrange them with 1 row and 2 columns

```




# Functions 4: Distribution Functions {.tabset .tabset-pills}

The dnorm(), pnorm() and qnorm() functions are used for continuous normal distributions. dbinorm(), pbinorm() and qbinorm() are binomial functions used for discrete distributions. 

## `dnorm()`
dnorm is the probability density function. You can us it to answer questions such as: is the value of 1.2 or 2.4 more likely?
```{r}
# the parameters required for dnorm() are x, mean and sd. The default setting are as follows dnorm(x, mean = 0, sd = 1, log = FALSE)
dnorm(1.2)

dnorm(2.4)
```


## `pnorm()`
pnorm is the cumulative density function. You can use this function to answer questions such as: what is the probability of observing a value of less than 1.2 from a normally-distributed population with mean = 2 and standard deviation = 3?
```{r}
# This gives you the values under the curve to the left (less than) the given value.
pnorm(1.2, mean = 2, sd = 3)

```

```{r}
# To find the values under the curve to the right of the given value (greater than) you need to use the law of probabilty like in the example below

1- pnorm(1.2, mean = 2, sd = 3)
```


## `qnorm()`

qnorm is the quantile function. You can answer questions such as: what is the 20th percentile of your data which has a mean of 5 and a standard deviation of 1?
```{r}
qnorm(.2, mean = 5, sd = 1)
```
? qnorm lower.tail = TRUE default is that a one tailed test by default 


## `dbinorm()`
dbinorm is the probability mass function. You can use these function to answer questions such as: what is the probability of observing exactly x = 3 with a sample size of 4 and a probability of .75?

```{r}
dbinom(3, size = 4, prob = 0.75)
```


## `pbinorm()`
pbinorm is the cumulative mass function. This function lets you answer questions such as: what is the probability of observing a count of x = 3 successes or fewer in a binomial distribution with a sample size of n = 4 and probability of p = 0.75?
```{r}
pbinom(3, size = 4, prob = 0.75)
```

You can use the law of probability to figure out the reciprocal value. What is the probability of observing a count of greater than 3 successes in a binomial distribution with a sample size of n = 4 and probability of p = 0.75?
```{r}

1- pbinom(3, size = 4, prob = 0.75)
```


## `qbinom()`
qbinom is the quantile function. You can use this function to answer questions such as: what is the 10th quantile of a binomial distribution with a sample size of 10 and a probability of success for each trial of .4?
```{r}

qbinom(.10, size = 10, prob = .4)

```




# Functions 5: Other Functions {.tabset .tabset-pills}

## `subset()`
```{r}
gentoo_penguins= subset(penguins,species == "Gentoo")

```

## `libary()` and `require()`
```{r}
require(palmerpenguins)
penguins<- penguins

```

## `read.csv()`
```{r}
#I downloaded the catrate data into R and convert it to a data frame with the read.csv(here(...)) function
catrate = read.csv(here("data", "catrate.csv"))
```








# Part 2: Data Anaylsis {.tabset .tabset-pills}

## Data Exploration {.tabset .tabset-pills}

### Numerical Exploration 

`summary()`
```{r}
library(here)
delomys_dat = read.csv(here("data", "delomys.csv"))
summary(delomys_dat$body_mass)
summary(delomys_dat$body_length)
```

`shapiro.test()`
```{r}
shapiro.test(delomys_dat$body_mass)
shapiro.test(delomys_dat$body_length)
```

### Graphical Exploration

scatterplot using `plot()`

```{r}

plot(body_length ~ body_mass, 
     data= delomys_dat)

```


histogram using `hist()`

```{r}
hist(delomys_dat$body_mass)
```

```{r}
hist(delomys_dat$body_length)
```

boxplot using `boxplot()`

```{r}
boxplot(body_mass ~ binomial, data = delomys_dat)
```

```{r}
boxplot(body_mass ~ sex, data = delomys_dat)
```

```{r}
boxplot(body_mass ~ sex * binomial, data = delomys_dat) 
```

Answer these questions:
Qualitatively describe the relationship between body mass and length.
Does the relationship seem linear, curved, nonexistent?
Qualitatively describe the shapes of the histograms.
Do the data appear normally-distributed? Explain why or why not.
Using both the histograms and normality tests, do you think the (unconditioned) body masses and body length are normally-distributed?
Contrast your visual assessment of normality to the results of the numerical normality tests.
Examine the conditional boxplots. Describe any graphical evidence you see for body mass differences based on species and/or sex.


## Model Building

Model 1: simple linear regression
```{r}
fit1 = lm(body_length ~ body_mass, data = delomys_dat)
```

Model 2: 1-way ANOVA body_mass ~ sex

```{r}
fit2 = lm(body_mass ~ sex, data = delomys_dat)
anova(fit2)

```

Model 3: 1-way ANOVA body_mass ~ binomial
```{r}
fit3 = lm(body_mass ~ binomial, data = delomys_dat)
anova(fit3)
```

Model 4: 2 additive ANOVA body_mass ~ sex + binomial

```{r}
fit4 = lm(body_mass ~ sex + binomial, data = delomys_dat)
anova(fit4)
```

Model 5: 2-way factorial ANOVA
```{r}
fit5 = lm(body_mass ~ sex * binomial, data = delomys_dat)
anova(fit5)
```




## Model Diagnostic

Residuals fit1
```{r}
resids_fit1 = residuals(fit1) 
hist(resids_fit1, 
     breaks = 80,
     xlim = c(-50, 50))

shapiro.test(resids_fit1)

```

Residuals fit2
```{r}
resids_fit2 = residuals(fit2)
hist(resids_fit2,
     breaks = 10)

shapiro.test(resids_fit2)

```

Residuals fit3
```{r}
resids_fit3 = residuals(fit3)
hist(resids_fit3,
     breaks = 20, 
     xlim = c(-60, 60))

shapiro.test(resids_fit3)
```

Residuals fit4
```{r}
resids_fit4 = residuals(fit4)
hist(resids_fit4)

shapiro.test(resids_fit4)

```

Residuals fit5
```{r}
resids_fit5 = residuals(fit5)
hist(resids_fit5)

shapiro_resids_5 = shapiro.test(resids_fit5)
str(shapiro_resids_5)
```

Answer these questions
What do you conclude about residual normality based on the numerical and graphical diagnostics?
Are violations of the normality assumption equally severe for all the models?

## Model Interpretation

Model fit 1: Simple linear regression

`body_length ~ body_mass`
```{r, }
knitr::kable(coef(summary(fit1)), digits = 2)

knitr::kable(anova(fit1), digits = 2)
```

Model fit 2
1-way ANOVA 
`body_mass ~ sex`

```{r}
knitr::kable(coef(summary(fit2)), digits = 2)

knitr::kable(anova(fit2), digits = 2)
```

Model fit 3
1-way ANOVA 
`body_mass ~ binomial`

```{r}
knitr::kable(coef(summary(fit3)), digits = 2)

knitr::kable(anova(fit3), digits = 2)
```

Model fit 4
2-way additive ANOVA
`body_mass ~ sex + binomial`

```{r}
knitr::kable(coef(summary(fit4)), digits = 2)

knitr::kable(anova(fit4), digits = 2)
```

Model fit 5
2-way factorial ANOVA
`body_mass ~ sex * binomial

```{r}
knitr::kable(coef(summary(fit5)), digits = 2)

knitr::kable(anova(fit5), digits = 2)
```



## Model Comparison: Body Mass

Model fit1 

```{r}
AIC(fit1)
```

Model fit2

```{r}
AIC(fit2)
```

Model fit3
```{r}
AIC(fit3)
```

Model fit4
```{r}
AIC(fit4)
```

Model fit5

```{r}
AIC(fit5)
```







Your data analysis materials will go here.



